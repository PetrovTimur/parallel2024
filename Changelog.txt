05.11
    - Initial submission

15.11
    - Распараллелил алгоритм создания массивов ia, ja (функция makeCSR в файле csr.cpp)
    - Соответствующие графики были добавлены в отчет
    - Изменил расчет показателей Arithmetic Intensity (AI) и расписал более подробно
    - Изменил конфигурацию cmake: библиотеки сохраняются в папку lib в корне проекта
    - Исправил распараллеливание некоторых тестов

Ответы на вопросы:

0) Вариант А1 получается (вставил картинку в отчет)

1) Вот это достаточно интересный момент, потому что у меня работает, как и на своем компьютере, так и на Полюсе. Я даже попробовал специально скачать архив на ноутбук, но и там все работает. Как будто бы у вас make не видит библиотеку Utilities, которая должна тоже компилироваться. Причем компилироваться она естественно должна до того, как будет происходить компиляция CGSolver. Вроде бы флаг распараллеливания -j не должен влиять на это, но можно попробовать без него. Ну и еще можно попробовать скомпилировать ее отдельно: make Utilities

3) Как будто бы казалось, что первое задание рассчитано на работу в системах с общей памятью (в рамках одного NUMA-узла). Насколько я понял на каждом вычислительном узле Полюса два сокета <--> два NUMA узла (проверял через lscpu). Каждому сокету соответствует процессор IBM POWER8, у которого собственно 10 ядер. Чтобы не выходить за рамки одного NUMA-узла я и прописываю *affinity[core(10):distribute=pack(socket=1)]*. Часть *distribute=pack(socket=1)*, насколько я понял из документации IBM, будет гарантировать мне, что все ядра выделяются на одном сокете (https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=strings-affinity-string).

4) Новые расчеты расписал более подробно в новой версии отчета
