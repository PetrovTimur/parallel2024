05.11
    - Initial submission



15.11
    - Распараллелил алгоритм создания массивов ia, ja (функция makeCSR в файле csr.cpp)
    - Соответствующие графики были добавлены в отчет
    - Изменил расчет показателей Arithmetic Intensity (AI) и расписал более подробно
    - Изменил конфигурацию cmake: библиотеки сохраняются в папку lib в корне проекта
    - Исправил распараллеливание некоторых тестов

Ответы на вопросы:

0) Вариант А1 получается (вставил картинку в отчет)

1) Вот это достаточно интересный момент, потому что у меня работает, как и на своем компьютере, так и на Полюсе. Я даже попробовал специально скачать архив на ноутбук, но и там все работает. Как будто бы у вас make не видит библиотеку Utilities, которая должна тоже компилироваться. Причем компилироваться она естественно должна до того, как будет происходить компиляция CGSolver. Вроде бы флаг распараллеливания -j не должен влиять на это, но можно попробовать без него. Ну и еще можно попробовать скомпилировать ее отдельно: make Utilities

3) Как будто бы казалось, что первое задание рассчитано на работу в системах с общей памятью (в рамках одного NUMA-узла). Насколько я понял на каждом вычислительном узле Полюса два сокета <--> два NUMA узла (проверял через lscpu). Каждому сокету соответствует процессор IBM POWER8, у которого собственно 10 ядер. Чтобы не выходить за рамки одного NUMA-узла я и прописываю *affinity[core(10):distribute=pack(socket=1)]*. Часть *distribute=pack(socket=1)*, насколько я понял из документации IBM, будет гарантировать мне, что все ядра выделяются на одном сокете (https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=strings-affinity-string).

4) Новые расчеты расписал более подробно в новой версии отчета



19.11

1) Действительно описаний никаких не было. Вообще по-хорошему это же вспомогательные программы (для измерений времени), хоть и лежат в папке тестов. Их наверное стоило завернуть в еще одну какую-нибудь cmake опцию, чтобы лишний раз не компилировались. Вывод там изначально был более понятный, но потом я его поменял на кривой, потому что мне так проще было копировать результаты измерений и вставлять в python листы для построения графиков. Так в итоге и забыл исправить.

3) Запустил на 2-х сокетах. Вроде бы пиковое ускорение выросло в 2 раза, значит наверное все работает правильно (графики и таблица на стр. 10). Единственное, что у меня так получилось, что был использован и *proc_bind(spread)*, и планировщик LSF для привязки нитей к ядру. Не знаю, насколько это может привести к конфликтным ситуациям...